---
format:
  revealjs:
    css: style.css
    theme: solarized
    slide-number: true
    code-line-numbers: false
    preview-links: auto
    keyboard: true
    touch: true
    help: true
    include-in-header: meta-tags.html
    link-external-newwindow: true
    mermaid-format: png
revealjs-plugins:
  - fontawesome
execute:
  echo: false
  eval: false
keywords: ["software-engineering", "r-packages", "best-practices", "DRY"]
pagetitle: "DRY R Package Development"
author-meta: "Indrajeet Patil"
date-meta: "`r Sys.time()`"
description-meta: "Learn how to apply the DRY (Don't Repeat Yourself) principle to R package development. Covers documentation, vignette setup, unit testing, data management, dependency management, and exception handling to make your R packages more maintainable."
license: "CC0 1.0 Universal"
lang: "en"
dir: "ltr"
image: "media/social-media-card.png"
image-alt: "Preview image for presentation about DRY (Don't Repeat Yourself) principle in R package development"
canonical-url: "https://indrajeetpatil.github.io/dry-r-package-development/"
---

## DRY Package Development in R {style="text-align: center;"}

<!-- Need to install extension from https://github.com/quarto-ext/fontawesome -->
<!-- Run `quarto install extension quarto-ext/fontawesome` in terminal -->

::: {style="text-align: center;"}

Indrajeet Patil

:::

```{r}
#| echo: false
#| eval: true
knitr::include_graphics("media/simpsons.png")
```

::: {style="text-align: center; font-size: 0.7em; margin-top: 2em; color: #666;"}
Source code for these slides can be found [on GitHub](https://github.com/IndrajeetPatil/dry-r-package-development/).
:::

# 

*"Copy and paste is a design error."* &nbsp; \- David Parnas

# Why So DRY

Why should you not repeat yourself?

## Don't Repeat Yourself (DRY) Principle {.smaller}

:::: {.columns}

::: {.column width='60%'}

The DRY Principle states that:

::: {style="color: red;"}

*Every piece of **knowledge** must have a **single** representation in the codebase.*

:::

That is, you should not express the same thing in multiple places in multiple ways.

:::

::: {.column width='40%'}

```{r, echo=FALSE, eval=TRUE}
knitr::include_graphics("media/dry.gif")
```

:::

::::

. . . 

:::{.callout-note}

## It's about *knowledge* and not just *code*

The DRY principle is about duplication of knowledge.
Thus, it applies to all programming entities that encode knowledge:

- You should not duplicate code.
- You should not duplicate intent across code and comments.
- You should not duplicate knowledge in data structures.
- ...

:::

## Benefits of DRY codebase {.smaller}

- Duplicated code requires parallel changes in multiple places; DRY code eliminates this need.

- Easier to maintain - update knowledge in one place only.

- Routines developed to remove duplicated code can become general-purpose utilities.

<br>

. . . 

:::{.callout-tip}

## Further Reading 

- Thomas, D., & Hunt, A. (2019). *The Pragmatic Programmer*. Addison-Wesley Professional. (**pp. 30-38**)

- Understand distinction between DRY and [DAMP (Descriptive And Meaningful Phrases)](https://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests)

:::

# Plan

Apply DRY to remove duplication in:

- Documentation
- Vignette setup
- Unit testing
- Dependency management
- Exceptions

# Documentation

Avoiding repetition in documentation.

## What do users read? {.smaller}

Users consult different sources depending on context.

<br>

. . .

{{< fa brands readme size=2xl >}} **README**: While exploring the package repository.

<br>

{{< fa file size=2xl >}} **Vignettes**: When first learning how to use a package.

<br>

{{< fa solid file-invoice size=2xl >}} **Manual**: When checking details about a specific function.

<br>

. . .

Including crucial information in only one place risks users missing it in certain contexts.

## Go forth and multiply (without repetition) {.smaller}

:::: {.columns}

::: {.column width='40%'}

Some documentation is important enough to be included in multiple places (e.g. in the function documentation and in a vignette).

<br>

> How can you document something just *once* but include it in *multiple* locations?

:::

::: {.column width='60%'}

```{r, echo=FALSE, eval=TRUE, out.width="100%"}
knitr::include_graphics("media/spiderman.jpeg")
```

:::

::::

## Child documents {.smaller}

You can stitch an R Markdown document from smaller [child documents](https://bookdown.org/yihui/rmarkdown-cookbook/child-document.html).

```{mermaid}
%%| eval: true
%%| fig-width: 7
%%| fig-height: 4.5
graph LR
    A[Parent Rmd] --> C[Result Rmd]
    B[Child Rmd] --> C
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#e8f5e9
```

. . .

Information is stored *once* in child documents and reused *multiple* times across parents.

## Storing child documents in package {.smaller}

Store child documents in the manual directory and reuse them.

:::: {.columns}

::: {.column width='30%'}

**Child documents**

```
├── DESCRIPTION
├── man
│   └── rmd-children
│       └── info1.Rmd
│       └── ...
```

:::

::: {.column width='70%'}

````{.markdown filename="info1.Rmd"}
This is some crucial information to be repeated across documentation.

```{{r}}
1 + 1
```

````

:::

::::

<br>

:::{.callout-tip}

## Tips

- Include as many child documents as needed.
- Child documents are standard `.Rmd` files with full `.Rmd` capabilities.
- You can choose a different name for the folder containing child documents (e.g. `rmd-fragments`).
- Make sure to include `Roxygen: list(markdown = TRUE)` field in the `DESCRIPTION` file.
- The child documents will not pose a problem either for `R CMD check` or for `{pkgdown}` website.

:::

## Using child documents in package: Part-1 {.smaller}

Include child document contents in multiple documentation locations.

. . . 

:::: {.columns}

::: {.column width='50%'}

**Vignette**

```
├── DESCRIPTION
├── vignettes
│   └── vignette1.Rmd
│   └── ...
│   └── web_only
│       └── vignette2.Rmd
│       └── ...
```

:::

::: {.column width='50%'}

**README**

```
├── DESCRIPTION
├── README.Rmd
```

:::

::::

. . . 

:::: {.columns}

::: {.column width='50%'}

````{.markdown filename="vignette1.Rmd"}
---
output: html_vignette
---

Vignette content.

```{{r}}, child="../man/rmd-children/info1.Rmd"}
```

````

:::

::: {.column width='50%'}

````{.markdown filename="README.Rmd"}
---
output: github_document
---

README content.

```{{r}}, child="man/rmd-children/info1.Rmd"}
```

````

:::

::::


## Using child documents in package: Part-2 {.smaller}

Include child document contents in multiple documentation locations.

:::: {.columns}

::: {.column width='30%'}

**Manual**

```
├── DESCRIPTION
├── R
│   └── foo1.R
│   └── foo2.R
├── man
│   └── foo1.Rd
│   └── foo2.Rd
│   └── ...
```

:::

::: {.column width='50%'}

```{.r filename="foo1.R"}
#' @title Foo1
#' @section Information:
#'
#' ```{r, child="man/rmd-children/info1.Rmd"}
#' ```
foo1 <- function() { ... }
```

:::

::::

<br>

:::{.callout-important}

The underlying assumption here is that you are using [`{roxygen2}`](https://roxygen2.r-lib.org/) to generate package documentation.

:::

## What about non-child documents? {.smaller}

You can include contents from **any** file in `.Rmd`, not just a child document!

```{mermaid}
%%| eval: true
%%| fig-width: 14
%%| fig-height: 4
graph TD
    A[Parent Rmd] --> F[Result Rmd]
    B[Child Rmd] --> F
    C[.R file<br/>R engine] --> F
    D[.md file<br/>asis engine] --> F
    E[...] --> F
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#ffe1f5
    style D fill:#f5e1ff
    style E fill:#f0f0f0
    style F fill:#e8f5e9
```

## Storing other documentation files in package {.smaller}

Like child documents, store other document types in the `man/` folder.

:::: {.columns}

::: {.column width='30%'}

**Reusable content**

```
├── DESCRIPTION
├── man
│   └── rmd-children
│       └── info1.Rmd
│       └── ...
│   └── md-fragments
│       └── fragment1.md
│       └── ...
│   └── r-chunks
│       └── chunk1.R
│       └── ...
```

:::

::: {.column width='35%'}

````{.markdown filename="fragment1.md"}
This `.md` file contains
content to be included *as is*
across multiple locations
in the documentation.
````

:::

::: {.column width='35%'}

````{.markdown filename="chunk1.R"}
# some comment and code
1 + 1

# more comments and code
2 + 3
````

:::

::::

<br>

:::{.callout-note}

## Folder names

Name folders to describe their contents (e.g., `r-examples`, `yaml-snippets`, `md-fragments`).

:::

## Using non-child documents in package: Part-1 {.smaller}

Include various file contents in multiple documentation locations.

. . . 

:::: {.columns}

::: {.column width='50%'}

**Vignette**

```
├── DESCRIPTION
├── vignettes
│   └── vignette1.Rmd
│   └── ...
│   └── web_only
│       └── vignette2.Rmd
│       └── ...
```

:::

::: {.column width='50%'}

**README**

```
├── DESCRIPTION
├── README.Rmd
```

:::

::::

. . . 

:::: {.columns}

::: {.column width='50%'}

````{.markdown filename="vignette1.Rmd"}
---
output: html_vignette
---

Vignette content.

```{{asis}}, file="../man/md-fragments/fragment1.md"}
```

```{{r}}, file="../man/r-chunks/chunk1.R"}
```

````

:::

::: {.column width='50%'}

````{.markdown filename="README.Rmd"}
---
output: github_document
---

README content.

```{{asis}}, file="man/md-fragments/fragment1.md"}
```

```{{r}}, file="man/r-chunks/chunk1.R"}
```

````

:::

::::

## Using non-child documents in package: Part-2 {.smaller}

Include child document contents in multiple documentation locations.

:::: {.columns}

::: {.column width='30%'}

**Manual**

```
├── DESCRIPTION
├── R
│   └── foo1.R
│   └── ...
├── man
│   └── foo1.Rd
│   └── ...
```

:::

::: {.column width='50%'}

```{.r filename="foo1.R"}
#' @title Foo1
#' @section Information:
#'
#' ```{r, file="man/md-fragments/fragment1.Rmd"}
#' ```
#'
#' @example man/r-chunks/chunk1.R
foo1 <- function() { ... }
```

:::

::::

<br>

:::{.callout-important}

The underlying assumption here is that you are using [`{roxygen2}`](https://roxygen2.r-lib.org/) to generate package documentation.

:::

##  

:::{.callout-tip}

## Summary on how to repeat documentation

If you are overwhelmed by this section, note that you actually need to remember only the following rules:

- Store reusable document files in the `/man` folder.

- When you wish to include their contents, provide paths to these files **relative** to the document you are linking from.

- If it's a child `.Rmd` document, use the `child` option to include its contents.

- If it's not an `.Rmd` document, use the `file` option to include its contents and use appropriate `{knitr}` engine. To see available engines, run `names(knitr::knit_engines$get())`.

:::

## Self-study

Example packages that use reusable component documents to repeat documentation.

- [`{pkgdown}`](https://github.com/r-lib/pkgdown/tree/main/man/rmd-fragments)

- [`{ggstatsplot}`](https://github.com/IndrajeetPatil/ggstatsplot/tree/main/man)

- [`{statsExpressions}`](https://github.com/IndrajeetPatil/statsExpressions/tree/main/man)

# Vignette Setup

Avoiding repetition in vignette setup.

## Setup chunks in vignettes {.smaller}

Setup chunks for vignettes often contain duplication.

Some setup code is identical across vignettes.

<br>

:::: {.columns}

::: {.column width='25%'}

```
├── DESCRIPTION
├── vignettes
│   └── vignette1.Rmd
│   └── vignette2.Rmd
│   └── ...
```

:::

::: {.column width='37%'}

````{.markdown filename="vignette1.Rmd"}
---
title: "Vignette-1"
output: html_vignette
---

```{{r}}
knitr::opts_chunk$set(
  message = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

````

:::

::: {.column width='37%'}

````{.markdown filename="vignette2.Rmd"}
---
title: "Vignette-2"
output: html_vignette
---

```{{r}}
knitr::opts_chunk$set(
  message = FALSE,
  collapse = TRUE,
  comment = "#>"
)

options(crayon.enabled = TRUE)
```

````

:::

::::

<br>

How can this repetition be avoided?

## Sourcing setup chunks in vignettes {.smaller}

:::: {.columns}

::: {.column width='60%'}

Avoid this by moving **common** setup to a script and sourcing it from vignettes. If you have many reusable artifacts, store scripts in a `/setup` folder.

:::

::: {.column width='20%'}

**Option 1**

```
├── DESCRIPTION
├── vignettes
│   └── setup.R
```

:::

::: {.column width='20%'}

**Option 2**

```
├── DESCRIPTION
├── vignettes
│   └── setup
│       └── setup.R
```

:::

::::

. . . 

:::: {.columns}

::: {.column width='26%'}

Common setup

```{.r filename="setup.R"}
knitr::opts_chunk$set(
  message = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

:::

::: {.column width='37%'}

Sourcing common setup

````{.markdown filename="vignette1.Rmd"}
---
title: "Vignette-1"
output: html_vignette
---

```{{r}} setup, include = FALSE}
source("setup/setup.R")
```

````

:::

::: {.column width='37%'}

Sourcing common setup

````{.markdown filename="vignette2.Rmd"}
---
title: "Vignette-2"
output: html_vignette
---

```{{r}} setup, include = FALSE}
source("setup/setup.R")
options(crayon.enabled = TRUE)
```

````

:::

::::

. . . 

:::{.callout-tip}

## No parallel modification

Modify common setup in *one* place only!

:::

## Self-study

Packages in the wild that use this trick.

- [`{dm}`](https://github.com/cynkra/dm/blob/main/vignettes/setup/setup.R)

- [`{statsExpressions}`](https://github.com/IndrajeetPatil/statsExpressions/blob/main/vignettes/setup.R)

# Data

Avoiding repetition with example datasets.

## Illustrative example datasets {.smaller}

Create new datasets when existing ones don't illustrate your functions well.

. . .

Using dataset `exdat` with function `foo()` in examples, vignettes, and README requires defining it *multiple* times.

:::: {.columns}

::: {.column width='33%'}

**In examples**

```{.r filename="foo.R"}
#' @examples
#' exdat <- matrix(c(71, 50))
#' foo(exdat)
```

:::

::: {.column width='33%'}

**In vignettes**

````{.markdown filename="vignette.Rmd"}
---
title: "My Vignette"
output: html_vignette
---

```{{r}}
exdat <- matrix(c(71, 50))
foo(exdat)
```
````

:::

::: {.column width='33%'}

**In README**

````{.markdown filename="README.Rmd"}
---
output: github_document
---

```{{r}}
exdat <- matrix(c(71, 50))
foo(exdat)
```
````

:::

::::

<br>

. . . 

How can this repetition be avoided?

## Shipping data in a package {.smaller}

Define data *once*, save it, and ship it with the package.

Store datasets in `data/` and document them in `R/data.R`.

. . . 

:::: {.columns}

::: {.column width='60%'}

**Saving data**

```{.r filename="exdat.R"}
exdat <- matrix(c(71, 50))
save(exdat, file="data/exdat.rdata")
```

:::

::: {.column width='40%'}

**Directory structure**

```
├── DESCRIPTION
├── R
├── data-raw
│   └── exdat.R
├── data
│   └── exdat.rdata
├── R
│   └── data.R
```

:::

::::

. . . 

:::{.callout-caution}

## Don't forget!

- Save the creation script in `data-raw/` for future updates.
- Set `LazyData: true` in `DESCRIPTION` when including datasets.

:::

## Reusable dataset {.smaller}

`exdat` can now be used everywhere without redefining it.

:::: {.columns}

::: {.column width='33%'}

**In examples**

```{.r filename="foo.R"}
#' @examples
#' foo(exdat)
```

:::

::: {.column width='33%'}

**In vignettes**

````{.markdown filename="vignette.Rmd"}
---
title: "My Vignette"
output: html_vignette
---

```{{r}}
foo(exdat)
```
````

:::

::: {.column width='33%'}

**In README**

````{.markdown filename="README.Rmd"}
---
output: github_document
---

```{{r}}
foo(exdat)
```
````

:::

::::

<br>


:::{.callout-tip}

## No parallel modification

Update the dataset in *one* place only!

:::

## Self-study

Examples of R packages that define datasets and use them repeatedly.

- [`{ggstatsplot}`](https://github.com/IndrajeetPatil/ggstatsplot)

- [`{effectsize}`](https://github.com/easystats/effectsize)

# Unit testing

Avoiding repetition in unit tests.

## Repeated test patterns {.smaller}

A **unit test** describes expected output.

<br>

(actual) {{< fa regular file-code size=2xl >}} {{< fa solid arrows-left-right size=2xl >}} {{< fa solid file-code size=2xl >}} (expected)

<br>

. . .

:::: {.columns}

::: {.column width='40%'}

Testing functions with a **range of inputs** often recycles test patterns.

:::{.callout-caution}

## Not DRY

But such recycling violates the DRY principle. How can you avoid this?

:::

:::

::: {.column width='60%'}

```{.r filename="multiplier.R"}
# Function to test
multiplier <- function(x, y) {
  x * y
}

# Tests
test_that(
  desc = "multiplier works as expected",
  code = {
    expect_identical(multiplier(-1, 3),  -3)
    expect_identical(multiplier(0,  3.4), 0)
    expect_identical(multiplier(NA, 4),   NA_real_)
    expect_identical(multiplier(-2, -2),  4)
    expect_identical(multiplier(3,  3),   9)
  }
)
```

:::

::::

## Parametrized unit testing {.smaller}

Write parameterized unit tests using [`{patrick}`](https://github.com/google/patrick).

. . . 

:::: {.columns}

::: {.column width='51%'}

**Repeated test pattern**

`expect_identical()` used repeatedly.

```{.r filename="test-multiplier.R"}
test_that(
  desc = "multiplier works as expected",
  code = {
    expect_identical(multiplier(-1, 3),  -3)
    expect_identical(multiplier(0,  3.4), 0)
    expect_identical(multiplier(NA, 4),   NA_real_)
    expect_identical(multiplier(-2, -2),  4)
    expect_identical(multiplier(3,  3),   9)
  }
)
```

:::

::: {.column width='49%'}

**Parametrized test pattern**

`expect_identical()` used once.

```{.r filename="test-multiplier.R"}
patrick::with_parameters_test_that(
  desc_stub = "multiplier works as expected",
  code = expect_identical(multiplier(x, y), res),
  .cases = tibble::tribble(
    ~x,  ~y,  ~res,
    -1,  3,   -3,
    0,   3.4,  0,
    NA,  4,    NA_real_,
    -2,  -2,   4,
    3,   3,    9
  )
)
```

:::

::::

:::{.callout-tip}

## Combinatorial explosion

The parametrized version may not seem impressive for this simple example, but it becomes exceedingly useful when there is a combinatorial explosion of possibilities. Creating each such test manually is cumbersome and error-prone.

:::

## Repeated usage of testing datasets {.smaller}

Like *user*-facing datasets, define *developer*-facing test datasets once and reuse them across multiple tests.

. . . 

:::: {.columns}

::: {.column width='40%'}

Either location works for saving datasets.

:::

::: {.column width='30%'}

```
├── DESCRIPTION
├── tests
│   └── data
│       └── script.R
│       └── testdat1.rdata
│       └── testdat2.rdata
│       └── ...
```

:::

::: {.column width='30%'}

```
├── DESCRIPTION
├── tests
│   └── testthat
│       └── data
│           └── script.R
│           └── testdat1.rdata
│           └── testdat2.rdata
│           └── ...
```

:::
::::

:::{.callout-caution}

## Save the script!

Always save the script used to create datasets. This script:

- acts as documentation for the datasets
- makes it easy to modify the datasets in the future (if needed)

:::

## Using test datasets {.smaller}

Without stored datasets, datasets are defined **multiple** times across test files.

:::: {.columns}

::: {.column width='35%'}

```{.r filename="test-foo1.R"}
testdat1 <- { ... }
foo1(testdat1)
```

:::

::: {.column width='35%'}

```{.r filename="test-foo2.R"}
testdat1 <- { ... }
foo2(testdat1)
```

:::

::: {.column width='30%'}

&nbsp; &nbsp; &nbsp; &nbsp; `...`

:::

::::

<br>

. . . 

With saved datasets, define **once** and load from test files.

:::: {.columns}

::: {.column width='35%'}

```{.r filename="test-foo1.R"}
testdat1 <- readRDS("testdat1")
foo1(testdat1)
```

:::

::: {.column width='35%'}

```{.r filename="test-foo2.R"}
testdat1 <- readRDS("testdat1")
foo2(testdat1)
```

:::


::: {.column width='30%'}

&nbsp; &nbsp; &nbsp; &nbsp; `...`

:::

::::

<br>

:::{.callout-note}

The exact path provided to `readRDS()` will depend on where the datasets are stored inside the `tests/` folder.

:::

## Self-study

Examples of R packages that save datasets required for unit testing.

- [`{ospsuite}`](https://github.com/Open-Systems-Pharmacology/OSPSuite-R/tree/develop/tests/data)

- [`{dm}`](https://github.com/cynkra/dm/tree/main/tests/testthat/dm)

# Exceptions

Avoiding repetition when signaling exceptions

## Sending signals {.smaller}

Functions use exceptions (messages, warnings, errors) to signal unexpected events. Similar exceptions are often signaled across functions.

. . . 

E.g., for functions that don't accept negative values:

**input validation**

:::: {.columns}

::: {.column width='50%'}

```{.r filename="foo1.R"}
foo1 <- function(x) {
  if (x < 0) {
    stop("Argument `x` should be positive.")
  }
  ...
}
```

:::

::: {.column width='50%'}

```{.r filename="foo2.R"}
foo2 <- function(y) {
  if (y < 0) {
    stop("Argument `y` should be positive.")
  }
  ...
}
```

:::

::::

**unit testing**

:::: {.columns}

::: {.column width='50%'}

```{.r filename="test-foo1.R"}
expect_error(
  foo1(-1),
  "Argument `x` should be positive."
)
```

:::

::: {.column width='50%'}

```{.r filename="test-foo2.R"}
expect_error(
  foo2(-1),
  "Argument `y` should be positive."
)
```

:::

::::

. . . 

How can this repetition be avoided?

## List of exception functions {.smaller}

Extract exception message strings into named functions and store them in a list.

```{.r filename="exceptions.R"}
exceptions <- list(
  only_positives_allowed = function(arg_name) {
    paste0("Argument `", arg_name, "` should be positive.")
  },

  ... # you can store as many functions as you want
)
```

:::{.callout-note}

## Why not include the entire validation?

You can move the entire `if()` block to `only_positives_allowed()` and create a new validation function.

But this is not done here to address the most general case where:

- the exception message string can be used outside of an `if()` block
- it can be used not only as a message, but may be as a warning or an error

:::

## Reusable exceptions: Part-1 {.smaller}

Use these functions to signal exceptions.

**Input validation**

:::: {.columns}

::: {.column width='50%'}

```{.r filename="foo1.R"}
foo1 <- function(x) {
  if (x < 0) {
    stop(exceptions$only_positives_allowed("x"))
  }
  ...
}
```

:::

::: {.column width='50%'}

```{.r filename="foo2.R"}
foo2 <- function(y) {
  if (y < 0) {
    stop(exceptions$only_positives_allowed("y"))
  }
  ...
}
```

:::

::::


**Unit testing**

:::: {.columns}

::: {.column width='50%'}

```{.r filename="test-foo1.R"}
expect_error(
  foo1(-1),
  exceptions$only_positives_allowed("x")
)
```

:::

::: {.column width='50%'}

```{.r filename="test-foo2.R"}
expect_error(
  foo2(-1),
  exceptions$only_positives_allowed("y")
)
```

:::

::::

<br>

:::{.callout-tip}

## No parallel modification

Change the condition string in *one* place only!

:::

## Reusable exceptions: Part-2 {.smaller}

:::: {.columns}

::: {.column width='30%'}

Alternatively, move entire validations to new functions:

:::

::: {.column width='70%'}

```{.r filename="exceptions.R"}
exceptions <- list(
  check_only_positive = function(arg) {
    arg_name <- deparse(substitute(arg))
    if (arg < 0) {
      stop(paste0("Argument `", arg_name, "` should be positive."))
    }
  },
  ... # you can store as many functions as you want
)
```

:::

::::

**Input validation**

:::: {.columns}

::: {.column width='50%'}

```{.r filename="foo1.R"}
foo1 <- function(x) {
  check_only_positive(x)
  ...
}
```

:::

::: {.column width='50%'}

```{.r filename="foo2.R"}
foo2 <- function(y) {
  check_only_positive(y)
  ...
}
```

:::

::::


**Unit testing**

:::: {.columns}

::: {.column width='50%'}

```{.r filename="test-check-only-positive.R"}
x <- -1
expect_error(
  exceptions$check_only_positive(x),
  "Argument `x` should be positive."
)
```

:::

::: {.column width='50%'}

Since the validation has moved to a new function, you only need to test it once.

:::

::::

## DRY once, DRY multiple times {.smaller}

Exceptions are usually useful only within their package. However, export generic exceptions to reuse them across packages.

DRYing up exceptions in one package does the same for many!

:::{.callout-note}

## Why a list?

Storing exceptions in a list is optional - individual functions work too.

Lists offer advantages:

- **Simpler `NAMESPACE`**: One export for all exceptions instead of dozens that can overpower the package API.

- **Extendability**: Easily append imported exceptions with package-specific ones (e.g., `exceptions$my_new_exception <- function() {...}`).

:::

## Self-study

Example of R package that create a list of exception functions and exports it:

[`{ospsuite.utils}`](https://github.com/Open-Systems-Pharmacology/OSPSuite.RUtils/blob/develop/R/messages.R)

Example of R package that imports this list and appends it:

[`{ospsuite}`](https://github.com/Open-Systems-Pharmacology/OSPSuite-R/blob/develop/R/messages.R)

# Dependency management

Avoiding repetition when importing external functions.

## Imports {.smaller}

Instead of using `::` to access external package functions (`rlang::warn()`), specify imports explicitly via `#' @importFrom`.

Collect repeated imports in a single file instead of specifying them multiple times.

. . . 

:::: {.columns}

::: {.column width='50%'}

Import statements scattered across files:

```{.r filename="Multiple R files"}
# file-1
#' @importFrom rlang warn
...

# file-2
#' @importFrom rlang warn
...

#' @importFrom purrr pluck
...

# file-3
#' @importFrom rlang warn seq2
...

# file-4, file-5, etc.
...
```

:::

::: {.column width='50%'}


Import statements in a single file:

```{.r filename="{pkgname}-package.R"}
## {pkgname} namespace: start
#'
#' @importFrom rlang warn seq2
#' @importFrom purrr pluck
#'
## {pkgname} namespace: end
NULL
```

:::

::::

## Self-study

Examples of R packages that list the `NAMESPACE` imports in a single file this way.

- [`{usethis}`](https://github.com/r-lib/usethis/blob/main/R/usethis-package.R)

- [`{lintr}`](https://github.com/r-lib/lintr/blob/main/R/lintr-package.R)

# Conclusion

These techniques make R package development faster, more maintainable, and less error-prone.

# Advanced {.smaller}

These meta-level topics are beyond this presentation's scope. See these resources to get started:

- [DRY GitHub Actions workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows)

   - <https://github.com/krlmlr/actions-sync>
   - <https://github.com/rstudio/education-workflows>

- [DRY pkdown website templates for multiple packages in organizations](https://pkgdown.r-lib.org/articles/customise.html#template-packages)

   - <https://github.com/tidyverse/tidytemplate>
   - <https://github.com/easystats/easystatstemplate>

# Thank You 

And Happy (DRY) Package Development! 😊

<br>
<br>

::: {style="text-align: center; font-size: 0.7em;"}

Check out my other [slide decks](https://sites.google.com/site/indrajeetspatilmorality/presentations) on software development best practices

:::

::: {style="text-align: center; font-size: 1em;"}

[{{< fa brands linkedin >}}](https://www.linkedin.com/in/indrajeet-patil-ph-d-397865174/)
&nbsp;&nbsp;
[{{< fa brands github >}}](http://github.com/IndrajeetPatil) 
&nbsp;&nbsp;
[{{< fa solid envelope >}}](mailto:patilindrajeet.science@gmail.com)

:::

