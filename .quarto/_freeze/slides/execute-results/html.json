{
  "hash": "c9b1fde0bad29e367808f355d887e434",
  "result": {
    "engine": "knitr",
    "markdown": "---\n#title: \"DRY R Package Development\"\nformat:\n  revealjs:\n    css: style.css\n    theme: solarized\n    slide-number: true\n    preview-links: auto\n    footer: \"Source code for the slides can be found [here](https://github.com/IndrajeetPatil/dry-r-package-development/){target='_blank'}.\"\n#author: \"Indrajeet Patil\"\n#affiliation: \nexecute:\n  echo: true\n  eval: false\nkeywords: [\"software-engineering\", \"r-packages\", \"best-practices\", \"DRY\"]\n---\n\n\n\n## DRY Package Development in R {style=\"text-align: center;\"}\n\n<!-- Don't render this file manually. Run `renderer.R` script instead. -->\n\n::: {style=\"text-align: center;\"}\n\nIndrajeet Patil\n\n:::\n\n![](media/simpsons.png){.absolute width=\"900\" height=\"500\" left=\"70\" top=\"155\"}\n\n<!-- Need to install extension from https://github.com/quarto-ext/fontawesome -->\n<!-- Run `quarto install extension quarto-ext/fontawesome` in terminal -->\n\n# \n\n*\"Copy and paste is a design error.\"* &nbsp; \\- David Parnas\n\n# Why So DRY\n\nWhy should you not repeat yourself?\n\n## Don't Repeat Yourself (DRY) Principle {.smaller}\n\n:::: {.columns}\n\n::: {.column width='60%'}\n\nThe DRY Principle states that:\n\n::: {style=\"color: red;\"}\n\n*Every piece of **knowledge** must have a **single** representation in the codebase.*\n\n:::\n\nThat is, you should not express the same thing in multiple places in multiple ways.\n\n:::\n\n::: {.column width='40%'}\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](media/dry.gif)\n:::\n:::\n\n\n\n:::\n\n::::\n\n. . . \n\n:::{.callout-note}\n\n## It's about *knowledge* and not just *code*\n\nThe DRY principle is about duplication of knowledge. \nThus, it applies to all programming entities that encode knowledge: \n\n- You should not duplicate code.\n- You should not duplicate intent across code and comments.\n- You should not duplicate knowledge in data structures.\n- ...\n\n:::\n\n## Benefits of DRY codebase {.smaller}\n\n- When code is duplicated, if you make change in one place, you need to make parallel changes in other places. When code is DRY, parallel modifications become unnecessary.\n\n- Easy to maintain since there is only a single representation of knowledge that needs to be updated if the underlying knowledge changes.\n\n- As a side effect, routines developed to remove duplicated code can become part of general-purpose utilities.\n\n<br>\n\n. . . \n\n:::{.callout-tip}\n\n## Further Reading \n\n- Thomas, D., & Hunt, A. (2019). *The Pragmatic Programmer*. Addison-Wesley Professional. (**pp. 30-38**)\n\n- Understand distinction between DRY and [DAMP (Descriptive And Meaningful Phrases)](https://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests){target=\"_blank\"}\n\n:::\n\n# Plan\n\nApply the DRY principle to remove duplication in following aspects of R package development:\n\n- Documentation\n- Vignette setup\n- Unit testing\n- Dependency management\n- Exceptions\n\n# Documentation\n\nHow not to repeat yourself while writing documentation.\n\n## What do users read? {.smaller}\n\nWhat users consult to find needed information may be context-dependent.\n\n<br>\n\n. . .\n\n{{< fa brands readme size=2xl >}} **README**: While exploring the package repository.\n\n<br>\n\n{{< fa file size=2xl >}} **Vignettes**: When first learning how to use a package.\n\n<br>\n\n{{< fa solid file-invoice size=2xl >}} **Manual**: When checking details about a specific function.\n\n<br>\n\n. . .\n\nThus, including crucial information **only in one place** makes it likely that the users might miss out on it in certain contexts.\n\n## Go forth and multiply (without repetition) {.smaller}\n\n:::: {.columns}\n\n::: {.column width='40%'}\n\nSome documentation is important enough to be included in multiple places (e.g. in the function documentation and in a vignette).\n\n<br>\n\n> How can you document something just *once* but include it in *multiple* locations?\n\n:::\n\n::: {.column width='60%'}\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](media/spiderman.jpeg){width=100%}\n:::\n:::\n\n\n\n:::\n\n::::\n\n## Child documents\n\nYou can stitch an R Markdown document from smaller [child documents](https://bookdown.org/yihui/rmarkdown-cookbook/child-document.html){target=\"_blank\"}.\n\n&nbsp; &nbsp; {{< fa regular file size=5x >}} &nbsp; &nbsp; {{< fa regular plus size=5x >}} &nbsp; &nbsp; {{< fa regular file-lines size=5x >}} &nbsp;&nbsp; {{< fa soliud equals size=5x >}} &nbsp;&nbsp; {{< fa solid file-lines size=5x >}}\n\n(parent Rmd) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (child Rmd) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (result Rmd)\n\n. . .\n\nThus, the information to repeat can be stored *once* in child documents and reused *multiple* times across parents.\n\n## Storing child documents in package {.smaller}\n\nStratagem: You can store child documents in the manual directory and reuse them.\n\n:::: {.columns}\n\n::: {.column width='30%'}\n\n**Child documents**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ man\nâ”‚   â””â”€â”€ rmd-children\nâ”‚       â””â”€â”€ info1.Rmd\nâ”‚       â””â”€â”€ ...\n```\n\n:::\n\n::: {.column width='70%'}\n\n`info1.Rmd` example:\n\n\n\n\n````{.default}\nThis is some crucial information to be repeated across documentation.\n\n```{r}\n1 + 1\n```\n\n````\n\n\n\n:::\n\n::::\n\n<br>\n\n:::{.callout-tip}\n\n## Tips\n\n- You can include as many child documents as you want.\n- The child document is just like any `.Rmd` file and can include everything that any other `.Rmd` file can include.\n- You can choose a different name for the folder containing child documents (e.g. `rmd-fragments`).\n- Make sure to include `Roxygen: list(markdown = TRUE)` field in the `DESCRIPTION` file.\n- The child documents will not pose a problem either for `R CMD check` or for `{pkgdown}` website.\n\n:::\n\n## Using child documents in package: Part-1 {.smaller}\n\nInclude contents of child documents in the documentation in multiple locations.\n\n. . . \n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n**Vignette**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ vignettes\nâ”‚   â””â”€â”€ vignette1.Rmd\nâ”‚   â””â”€â”€ ...\nâ”‚   â””â”€â”€ web_only\nâ”‚       â””â”€â”€ vignette2.Rmd\nâ”‚       â””â”€â”€ ...\n```\n\n:::\n\n::: {.column width='50%'}\n\n**README**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ README.Rmd\n```\n\n:::\n\n::::\n\n. . . \n\n:::: {.columns}\n\n::: {.column width='50%'}\n\nIn `vignette1.Rmd`\n\n\n\n\n````{.default}\n---\noutput: html_vignette\n---\n\nVignette content.\n\n```{r, child=\"../man/rmd-children/info1.Rmd\"}\n```\n\n````\n\n\n\n:::\n\n::: {.column width='50%'}\n\nIn `README.Rmd`\n\n\n\n\n````{.default}\n---\noutput: github_document\n---\n\nREADME content.\n\n```{r, child=\"man/rmd-children/info1.Rmd\"}\n```\n\n````\n\n\n\n:::\n\n::::\n\n\n## Using child documents in package: Part-2 {.smaller}\n\nInclude contents of child documents in the documentation in multiple locations.\n\n:::: {.columns}\n\n::: {.column width='30%'}\n\n**Manual**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ R\nâ”‚   â””â”€â”€ foo1.R\nâ”‚   â””â”€â”€ foo2.R\nâ”œâ”€â”€ man\nâ”‚   â””â”€â”€ foo1.Rd\nâ”‚   â””â”€â”€ foo2.Rd\nâ”‚   â””â”€â”€ ...\n```\n\n:::\n\n::: {.column width='50%'}\n\nIn `foo1.R`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @title Foo1\n#' @section Information:\n#' \n#' ```{r, child=\"man/rmd-children/info1.Rmd\"}\n#' ```\nfoo1 <- function() { ... }\n```\n:::\n\n\n\n:::\n\n::::\n\n<br>\n\n:::{.callout-important}\n\nThe underlying assumption here is that you are using [`{roxygen2}`](https://roxygen2.r-lib.org/) to generate package documentation.\n\n:::\n\n## What about non-child documents? {.smaller}\n\nYou can include contents from **any** file in `.Rmd`, not just a child document!\n\n<br>\n\n&nbsp; &nbsp; {{< fa regular file size=5x >}} \n&nbsp; &nbsp; {{< fa regular plus size=3x >}}\n&nbsp; &nbsp; {{< fa regular file-lines size=5x >}} \n&nbsp; &nbsp; {{< fa regular plus size=3x >}}\n&nbsp; &nbsp; {{< fa regular file-code size=5x >}} \n&nbsp; &nbsp; {{< fa regular plus size=3x >}}\n&nbsp; &nbsp; {{< fa regular file-image size=5x >}} \n&nbsp; &nbsp; {{< fa regular plus size=3x >}}\n&nbsp; &nbsp; {{< fa solid ellipsis size=2x >}}\n\n(parent Rmd) &nbsp; &nbsp; &nbsp; \n(child Rmd) &nbsp; &nbsp; &nbsp;\n(`.R` + `R` engine) &nbsp; \n(`.md` + `asis` engine) &nbsp; &nbsp; \n\n<br>\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {{< fa regular equals size=3x >}} \n&nbsp; &nbsp; {{< fa solid file-lines size=5x >}} \n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; (result Rmd)\n\n## Storing other documentation files in package {.smaller}\n\nLike child documents, other types of documents are also stored in `man/` folder.\n\n:::: {.columns}\n\n::: {.column width='30%'}\n\n**Reusable content**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ man\nâ”‚   â””â”€â”€ rmd-children\nâ”‚       â””â”€â”€ info1.Rmd\nâ”‚       â””â”€â”€ ...\nâ”‚   â””â”€â”€ md-fragments\nâ”‚       â””â”€â”€ fragment1.md\nâ”‚       â””â”€â”€ ...\nâ”‚   â””â”€â”€ r-chunks\nâ”‚       â””â”€â”€ chunk1.R\nâ”‚       â””â”€â”€ ...\n```\n\n:::\n\n::: {.column width='35%'}\n\n`fragment1.md` example:\n\n\n\n\n```{.default}\nThis `.md` file contains \ncontent to be included *as is*\nacross multiple locations\nin the documentation.\n```\n\n\n\n:::\n\n::: {.column width='35%'}\n\n`chunk1.R` example:\n\n\n\n\n```{.default}\n# some comment and code\n1 + 1\n\n# more comments and code\n2 + 3\n```\n\n\n\n:::\n\n::::\n\n<br>\n\n:::{.callout-note}\n\n## Folder names\n\nYou can name these folders however you wish, but it is advisable that the names provide information about file contents (e.g., `r-examples`, `yaml-snippets`, `md-fragments`, etc.).\n\n:::\n\n## Using non-child documents in package: Part-1 {.smaller}\n\nInclude contents of various files in the documentation in multiple locations.\n\n. . . \n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n**Vignette**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ vignettes\nâ”‚   â””â”€â”€ vignette1.Rmd\nâ”‚   â””â”€â”€ ...\nâ”‚   â””â”€â”€ web_only\nâ”‚       â””â”€â”€ vignette2.Rmd\nâ”‚       â””â”€â”€ ...\n```\n\n:::\n\n::: {.column width='50%'}\n\n**README**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ README.Rmd\n```\n\n:::\n\n::::\n\n. . . \n\n:::: {.columns}\n\n::: {.column width='50%'}\n\nIn `vignette1.Rmd`\n\n\n\n\n````{.default}\n---\noutput: html_vignette\n---\n\nVignette content.\n\n```{asis, file=\"../man/md-fragments/fragment1.md\"}\n```\n\n```{r, file=\"../man/r-chunks/chunk1.R\"}\n```\n\n````\n\n\n\n:::\n\n::: {.column width='50%'}\n\nIn `README.Rmd`\n\n\n\n\n````{.default}\n---\noutput: github_document\n---\n\nREADME content.\n\n```{asis, file=\"man/md-fragments/fragment1.md\"}\n```\n\n```{r, file=\"man/r-chunks/chunk1.R\"}\n```\n\n````\n\n\n\n:::\n\n::::\n\n## Using non-child documents in package: Part-2 {.smaller}\n\nInclude contents of child documents in the documentation in multiple locations.\n\n:::: {.columns}\n\n::: {.column width='30%'}\n\n**Manual**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ R\nâ”‚   â””â”€â”€ foo1.R\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ man\nâ”‚   â””â”€â”€ foo1.Rd\nâ”‚   â””â”€â”€ ...\n```\n\n:::\n\n::: {.column width='50%'}\n\nIn `foo1.R`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @title Foo1\n#' @section Information:\n#' \n#' ```{r, file=\"man/md-fragments/fragment1.Rmd\"}\n#' ```\n#' \n#' @example man/r-chunks/chunk1.R\nfoo1 <- function() { ... }\n```\n:::\n\n\n\n:::\n\n::::\n\n<br>\n\n:::{.callout-important}\n\nThe underlying assumption here is that you are using [`{roxygen2}`](https://roxygen2.r-lib.org/) to generate package documentation.\n\n:::\n\n##  \n\n:::{.callout-tip}\n\n## Summary on how to repeat documentation\n\nIf you are overwhelmed by this section, note that you actually need to remember only the following rules:\n\n- Store reusable document files in the `/man` folder.\n\n- When you wish to include their contents, provide paths to these files **relative** to the document you are linking from.\n\n- If it's a child `.Rmd` document, use the `child` option to include its contents.\n\n- If it's not an `.Rmd` document, use the `file` option to include its contents and use appropriate `{knitr}` engine. To see available engines, run `names(knitr::knit_engines$get())`.\n\n:::\n\n## Self-study\n\nExample packages that use reusable component documents to repeat documentation.\n\n- [`{pkgdown}`](https://github.com/r-lib/pkgdown/tree/main/man/rmd-fragments){target=\"_blank\"}\n\n- [`{ggstatsplot}`](https://github.com/IndrajeetPatil/ggstatsplot/tree/main/man){target=\"_blank\"}\n\n- [`{statsExpressions}`](https://github.com/IndrajeetPatil/statsExpressions/tree/main/man){target=\"_blank\"}\n\n# Vignette Setup\n\nHow not to repeat yourself while setting up vignettes.\n\n## Setup chunks in vignettes {.smaller}\n\nAnother duplication that occurs is in setup chunks for vignettes. \n\nFor example, some parts of the setup can be same across vignettes.\n\n<br>\n\n:::: {.columns}\n\n::: {.column width='25%'}\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ vignettes\nâ”‚   â””â”€â”€ vignette1.Rmd\nâ”‚   â””â”€â”€ vignette2.Rmd\nâ”‚   â””â”€â”€ ...\n```\n\n:::\n\n::: {.column width='37%'}\n\n\n\n\n````{.default}\n---\ntitle: \"Vignette-1\"\noutput: html_vignette\n---\n\n```{r}\nknitr::opts_chunk$set(\n  message = FALSE,\n  collapse = TRUE,\n  comment = \"#>\"\n)\n```\n\n````\n\n\n\n:::\n\n::: {.column width='37%'}\n\n\n\n\n````{.default}\n---\ntitle: \"Vignette-2\"\noutput: html_vignette\n---\n\n```{r}\nknitr::opts_chunk$set(\n  message = FALSE,\n  collapse = TRUE,\n  comment = \"#>\"\n)\n\noptions(crayon.enabled = TRUE)\n```\n\n````\n\n\n\n:::\n\n::::\n\n<br>\n\nHow can this repetition be avoided?\n\n## Sourcing setup chunks in vignettes {.smaller}\n\n:::: {.columns}\n\n::: {.column width='60%'}\n\nThis repetition can be avoided by moving the **common** setup to a script, and sourcing it from vignettes. Storing this script in a folder (`/setup`) is advisable if there are many reusable artifacts.\n\n:::\n\n::: {.column width='20%'}\n\n**Option 1**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ vignettes\nâ”‚   â””â”€â”€ setup.R\n```\n\n:::\n\n::: {.column width='20%'}\n\n**Option 2**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ vignettes\nâ”‚   â””â”€â”€ setup\nâ”‚       â””â”€â”€ setup.R\n```\n\n:::\n\n::::\n\n. . . \n\n:::: {.columns}\n\n::: {.column width='26%'}\n\n`setup.R` contents\n\n```{.r}\nknitr::opts_chunk$set(\n  message = FALSE,\n  collapse = TRUE,\n  comment = \"#>\"\n)\n```\n\n:::\n\n::: {.column width='37%'}\n\nSourcing common setup\n\n\n\n\n````{.default}\n---\ntitle: \"Vignette-1\"\noutput: html_vignette\n---\n\n```{r setup, include = FALSE}\nsource(\"setup/setup.R\")\n```\n\n````\n\n\n\n:::\n\n::: {.column width='37%'}\n\nSourcing common setup\n\n\n\n\n````{.default}\n---\ntitle: \"Vignette-2\"\noutput: html_vignette\n---\n\n```{r setup, include = FALSE}\nsource(\"setup/setup.R\")\noptions(crayon.enabled = TRUE)\n```\n\n````\n\n\n\n:::\n\n::::\n\n. . . \n\n:::{.callout-tip}\n\n## No parallel modification\n\nNow common setup can be modified with a change in only *one* place!\n\n:::\n\n## Self-study\n\nPackages in the wild that use this trick.\n\n- [`{dm}`](https://github.com/cynkra/dm/blob/main/vignettes/setup/setup.R){target=\"_blank\"}\n\n- [`{statsExpressions}`](https://github.com/IndrajeetPatil/statsExpressions/blob/main/vignettes/setup.R){target=\"_blank\"}\n\n# Data\n\nHow not to repeat yourself while creating and re-using example datasets.\n\n## Illustrative example datasets {.smaller}\n\nIf none of the existing datasets are useful to illustrate your functions, you can create new datasets.\n\n. . . \n\nLet's say your example dataset is called `exdat` and function is called `foo()`. Using it in examples, vignettes, README, etc. requires that it be define *multiple* times.\n\n:::: {.columns}\n\n::: {.column width='33%'}\n\n**In examples**\n\n```{.r}\n#' @examples\n#' exdat <- matrix(c(71, 50))\n#' foo(exdat)\n```\n\n:::\n\n::: {.column width='33%'}\n\n**In vignettes**\n\n\n\n\n````{.default}\n---\ntitle: \"My Vignette\"\noutput: html_vignette\n---\n\n```{r}\nexdat <- matrix(c(71, 50))\nfoo(exdat)\n```\n````\n\n\n\n:::\n\n::: {.column width='33%'}\n\n**In README**\n\n\n\n\n````{.default}\n---\noutput: github_document\n---\n\n```{r}\nexdat <- matrix(c(71, 50))\nfoo(exdat)\n```\n````\n\n\n\n:::\n\n::::\n\n<br>\n\n. . . \n\nHow can this repetition be avoided?\n\n## Shipping data in a package {.smaller}\n\nYou can avoid this repetition by defining the data just *once*, saving and shipping it with the package.\n\nThe datasets are stored in `data/`, and documented in `R/data.R`.\n\n. . . \n\n:::: {.columns}\n\n::: {.column width='70%'}\n\n**Saving data**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# In `exdat.R`\nexdat <- matrix(c(71, 50))\nsave(exdat, file=\"data/exdat.rdata\")\n```\n:::\n\n\n\n:::\n\n::: {.column width='30%'}\n\n**Directory structure**\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ R\nâ”œâ”€â”€ data-raw\nâ”‚   â””â”€â”€ exdat.R\nâ”œâ”€â”€ data\nâ”‚   â””â”€â”€ exdat.rdata\nâ”œâ”€â”€ R\nâ”‚   â””â”€â”€ data.R\n```\n\n:::\n\n::::\n\n. . . \n\n:::{.callout-caution}\n\n## Don't forget!\n\n- For future reference, save script (in `data-raw/` folder) to (re)create or update the dataset.\n- If you include datasets, set `LazyData: true` in the `DESCRIPTION` file.\n\n:::\n\n## Reusable dataset {.smaller}\n\n`exdat` can now be used in examples, tests, vignettes, etc.; there is no need to define it every time it is used.\n\n:::: {.columns}\n\n::: {.column width='33%'}\n\n**In examples**\n\n```{.r}\n#' @examples\n#' foo(exdat)\n```\n\n:::\n\n::: {.column width='33%'}\n\n**In vignettes**\n\n\n\n\n````{.default}\n---\ntitle: \"My Vignette\"\noutput: html_vignette\n---\n\n```{r}\nfoo(exdat)\n```\n````\n\n\n\n:::\n\n::: {.column width='33%'}\n\n**In README**\n\n\n\n\n````{.default}\n---\noutput: github_document\n---\n\n```{r}\nfoo(exdat)\n```\n````\n\n\n\n:::\n\n::::\n\n<br>\n\n\n:::{.callout-tip}\n\n## No parallel modification\n\nNote that if you now wish to update the dataset, you need to change its definition only in *one* place!\n\n:::\n\n## Self-study\n\nExamples of R packages that define datasets and use them repeatedly.\n\n- [`{ggstatsplot}`](https://github.com/IndrajeetPatil/ggstatsplot){target=\"_blank\"}\n\n- [`{effectsize}`](https://github.com/easystats/effectsize){target=\"_blank\"}\n\n# Unit testing\n\nHow not to repeat yourself while writing unit tests.\n\n## Repeated test patterns {.smaller}\n\nA **unit test** records the code to describe expected output.\n\n<br>\n\n(actual) {{< fa regular file-code size=2xl >}} {{< fa solid arrows-left-right size=2xl >}} {{< fa solid file-code size=2xl >}} (expected)\n\n<br>\n\n. . .\n\n:::: {.columns}\n\n::: {.column width='40%'}\n\nUnit testing involves checking function output with a **range of inputs**, and this can involve recycling a test pattern.\n\n:::{.callout-caution}\n\n## Not DRY\n\nBut such recycling violates the DRY principle. How can you avoid this?\n\n:::\n\n:::\n\n::: {.column width='60%'}\n\n```{.r}\n# Function to test\nmultiplier <- function(x, y) {\n  x * y\n}\n\n# Tests\ntest_that(\n  desc = \"multiplier works as expected\",\n  code = {\n    expect_identical(multiplier(-1, 3),  -3)\n    expect_identical(multiplier(0,  3.4), 0)\n    expect_identical(multiplier(NA, 4),   NA_real_)\n    expect_identical(multiplier(-2, -2),  4)\n    expect_identical(multiplier(3,  3),   9)\n  }\n)\n```\n\n:::\n\n::::\n\n## Parametrized unit testing {.smaller}\n\nTo avoid such repetition, you can write parameterized unit tests using  [`{patrick}`](https://github.com/google/patrick){target=\"_blank\"}.\n\n. . . \n\n:::: {.columns}\n\n::: {.column width='51%'}\n\n**Repeated test pattern**\n\n`expect_identical()` used repeatedly.\n\n```{.r}\ntest_that(\n  desc = \"multiplier works as expected\",\n  code = {\n    expect_identical(multiplier(-1, 3),  -3)\n    expect_identical(multiplier(0,  3.4), 0)\n    expect_identical(multiplier(NA, 4),   NA_real_)\n    expect_identical(multiplier(-2, -2),  4)\n    expect_identical(multiplier(3,  3),   9)\n  }\n)\n```\n\n:::\n\n::: {.column width='49%'}\n\n**Parametrized test pattern**\n\n`expect_identical()` used once.\n\n```{.r}\npatrick::with_parameters_test_that(\n  desc_stub = \"multiplier works as expected\",\n  code = expect_identical(multiplier(x, y), res),\n  .cases = tibble::tribble(\n    ~x,  ~y,  ~res,\n    -1,  3,   -3,\n    0,   3.4,  0,\n    NA,  4,    NA_real_,\n    -2,  -2,   4,\n    3,   3,    9\n  )\n)\n```\n\n:::\n\n::::\n\n:::{.callout-tip}\n\n## Combinatorial explosion\n\nThe parametrized version may not seem impressive for this simple example, but it becomes exceedingly useful when there is a combinatorial explosion of possibilities. Creating each such test manually is cumbersome and error-prone.\n\n:::\n\n## Repeated usage of testing datasets {.smaller}\n\nYou have already seen how *user*-facing datasets â€” useful for illustrating function usage â€” can be defined and saved once and then used repeatedly.\n\nSimilarly, you can define and save *developer*-facing datasets - useful for testing purposes - and use them across multiple tests.\n\n. . . \n\n:::: {.columns}\n\n::: {.column width='40%'}\n\nSaving datasets in either of these locations is fine.\n\n:::\n\n::: {.column width='30%'}\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ tests\nâ”‚   â””â”€â”€ data\nâ”‚       â””â”€â”€ script.R\nâ”‚       â””â”€â”€ testdat1.rdata\nâ”‚       â””â”€â”€ testdat2.rdata\nâ”‚       â””â”€â”€ ...\n```\n\n:::\n\n::: {.column width='30%'}\n\n```\nâ”œâ”€â”€ DESCRIPTION\nâ”œâ”€â”€ tests\nâ”‚   â””â”€â”€ testthat\nâ”‚       â””â”€â”€ data\nâ”‚           â””â”€â”€ script.R\nâ”‚           â””â”€â”€ testdat1.rdata\nâ”‚           â””â”€â”€ testdat2.rdata\nâ”‚           â””â”€â”€ ...\n```\n\n:::\n::::\n\n:::{.callout-caution}\n\n## Save the script!\n\nAlways save the script used to create datasets. This script:\n\n- acts as documentation for the datasets\n- makes it easy to modify the datasets in the future (if needed)\n\n:::\n\n## Using test datasets {.smaller}\n\nWithout stored datasets, you define the same datasets **multiple** times across test files.\n\n:::: {.columns}\n\n::: {.column width='35%'}\n\nIn `test-foo1.R`:\n\n```r\ntestdat1 <- { ... }\nfoo1(testdat1)\n```\n\n:::\n\n::: {.column width='35%'}\n\nIn `test-foo2.R`:\n\n```r\ntestdat1 <- { ... }\nfoo2(testdat1)\n```\n\n:::\n\n::: {.column width='30%'}\n\n&nbsp; &nbsp; &nbsp; &nbsp; `...`\n\n:::\n\n::::\n\n<br>\n\n. . . \n\nWith saved datasets, you define just **once** and load them from test files.\n\n:::: {.columns}\n\n::: {.column width='35%'}\n\nIn `test-foo1.R`:\n\n```r\ntestdat1 <- readRDS(\"testdat1\")\nfoo1(testdat1)\n```\n\n:::\n\n::: {.column width='35%'}\n\nIn `test-foo2.R`:\n\n```r\ntestdat1 <- readRDS(\"testdat1\")\nfoo2(testdat1)\n```\n\n:::\n\n\n::: {.column width='30%'}\n\n&nbsp; &nbsp; &nbsp; &nbsp; `...`\n\n:::\n\n::::\n\n<br>\n\n:::{.callout-note}\n\nThe exact path provided to `readRDS()` will depend on where the datasets are stored inside the `tests/` folder.\n\n:::\n\n## Self-study\n\nExamples of R packages that save datasets required for unit testing.\n\n- [`{ospsuite}`](https://github.com/Open-Systems-Pharmacology/OSPSuite-R/tree/develop/tests/data){target=\"_blank\"}\n\n- [`{dm}`](https://github.com/cynkra/dm/tree/main/tests/testthat/dm){target=\"_blank\"}\n\n# Exceptions\n\nHow not to repeat yourself while signalling exceptions\n\n## Sending signals {.smaller}\n\nExceptions/conditions (messages, warnings, and errors) provide a way for functions to signal to the user that something unexpected happened. Often, similar exceptions need to be signalled across functions.\n\n. . . \n\nE.g., for functions that don't accept negative values:\n\n**input validation**\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n```{.r}\nfoo1 <- function(x) {\n  if (x < 0) {\n    stop(\"Argument `x` should be positive.\")\n  }\n  \n  ...\n}\n```\n\n:::\n\n::: {.column width='50%'}\n\n```{.r}\nfoo2 <- function(y) {\n  if (y < 0) {\n    stop(\"Argument `y` should be positive.\")\n  }\n  \n  ...\n}\n```\n\n:::\n\n::::\n\n**unit testing**\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n```{.r}\nexpect_error(\n  foo1(-1), \n  \"Argument `x` should be positive.\"\n)\n```\n\n:::\n\n::: {.column width='50%'}\n\n```{.r}\nexpect_error(\n  foo2(-1), \n  \"Argument `y` should be positive.\"\n)\n```\n\n:::\n\n::::\n\n. . . \n\nHow can this repetition be avoided?\n\n## List of exception functions {.smaller}\n\nWe can avoid this repetition by extracting exception message strings in a function with an informative name. And then storing them in a list.\n\n```r\nexceptions <- list(\n  only_positives_allowed = function(arg_name) {\n    paste0(\"Argument `\", arg_name, \"` should be positive.\")\n  },\n  \n  ... # you can store as many functions as you want\n)\n```\n\n:::{.callout-note}\n\n## Why not include the entire validation?\n\nYou can move the entire `if()` block to `only_positives_allowed()` and create a new validation function.\n\nBut this is not done here to address the most general case where:\n\n- the exception message string can be used outside of an `if()` block\n- it can be used not only as a message, but may be as a warning or an error\n\n:::\n\n## Reusable exceptions: Part-1 {.smaller}\n\nWe can then use these functions to signal exceptions.\n\n**Input validation**\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n```r\nfoo1 <- function(x) {\n  if (x < 0) {\n    stop(exceptions$only_positives_allowed(\"x\"))\n  }\n  \n  ...\n}\n```\n\n:::\n\n::: {.column width='50%'}\n\n```r\nfoo2 <- function(y) {\n  if (y < 0) {\n    stop(exceptions$only_positives_allowed(\"y\"))\n  }\n  \n  ...\n}\n```\n\n:::\n\n::::\n\n\n**Unit testing**\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n```{.r}\nexpect_error(\n  foo1(-1), \n  exceptions$only_positives_allowed(\"x\")\n)\n```\n\n:::\n\n::: {.column width='50%'}\n\n```{.r}\nexpect_error(\n  foo2(-1), \n  exceptions$only_positives_allowed(\"y\")\n)\n```\n\n:::\n\n::::\n\n<br>\n\n:::{.callout-tip}\n\n## No parallel modification\n\nNote that if you now wish to change the condition string, this change needs to be made only in *one* place!\n\n:::\n\n## Reusable exceptions: Part-2 {.smaller}\n\nAs noted before, you can also move the entire validation to a new function. E.g.\n\n```{.r}\nexceptions <- list(\n  check_only_positive = function(arg) {\n    arg_name <- deparse(substitute(arg))\n    if (arg < 0) {\n      stop(paste0(\"Argument `\", arg_name, \"` should be positive.\"))\n    }\n  },\n  ... # you can store as many functions as you want\n)\n```\n\n**Input validation**\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n```{.r}\nfoo1 <- function(x) {\n  check_only_positive(x)\n  \n  ...\n}\n```\n\n:::\n\n::: {.column width='50%'}\n\n```{.r}\nfoo2 <- function(y) {\n  check_only_positive(y)\n  \n  ...\n}\n```\n\n:::\n\n::::\n\n\n**Unit testing**\n\n:::: {.columns}\n\n::: {.column width='50%'}\n\n```{.r}\nx <- -1\nexpect_error(\n  exceptions$check_only_positive(x), \n  \"Argument `x` should be positive.\"\n)\n```\n\n:::\n\n::: {.column width='50%'}\n\nSince the validation has moved to a new function, you only need to test it once.\n\n:::\n\n::::\n\n## DRY once, DRY multiple times {.smaller}\n\nMost often the exceptions will be useful only for the package in which they are defined in. But, if the exceptions are generic enough, you can even export them. This will make them reusable not only in the current package, but also in other packages. \n\nThat is, DRYing up exceptions in one package does the same for many!\n\n:::{.callout-note}\n\n## Why a list?\n\nIt is not *necessary* that you store exceptions in a list; you can create individual functions outside of a list and export them. \n\nBut storing them in a list has the following advantages:\n\n- **Simpler `NAMESPACE`**: There is a *single* export for all exceptions (e.g. `exceptions`), instead of dozens (e.g., `only_positives_allowed()`, `only_negatives_allowed`, `only_scalar_allowed()`, etc.), which can overpower the rest of the package API.\n\n- **Extendability**: You can easily append a list of imported exceptions by adding more exceptions which are relevant only for the current package. E.g. `exceptions$my_new_exception_function <- function() {...}`\n\n:::\n\n## Self-study\n\nExample of R package that create a list of exception functions and exports it:\n\n[`{ospsuite.utils}`](https://github.com/Open-Systems-Pharmacology/OSPSuite.RUtils/blob/develop/R/messages.R){target=\"_blank\"}\n\nExample of R package that imports this list and appends it:\n\n[`{ospsuite}`](https://github.com/Open-Systems-Pharmacology/OSPSuite-R/blob/develop/R/messages.R){target=\"_blank\"}\n\n# Dependency management\n\nHow not to repeat yourself while importing external package functions.\n\n## Imports {.smaller}\n\nInstead of using `::` to access external package function (`rlang::warn()`), you can specify imports explicitly via roxygen directive `#' @importFrom`.\n\nBut if you are importing some functions multiple times, you should avoid specifying the import multiple times, and instead collect all imports in a single file.\n\n. . . \n\n:::: {.columns}\n\n::: {.column width='50%'}\n\nImport statements scattered across files:\n\n```{.r}\n# file-1\n#' @importFrom rlang warn\n...\n\n# file-2\n#' @importFrom rlang warn\n...\n\n#' @importFrom purrr pluck\n...\n\n# file-3\n#' @importFrom rlang warn seq2\n...\n\n# file-4, file-5, etc.\n...\n```\n\n:::\n\n::: {.column width='50%'}\n\nIn `{pkgname}-package.R` file:\n\n```{.r}\n## {pkgname} namespace: start\n#'\n#' @importFrom rlang warn seq2\n#' @importFrom purrr pluck\n#'\n## {pkgname} namespace: end\nNULL\n```\n\n:::\n\n::::\n\n## Self-study\n\nExamples of R packages that list the `NAMESPACE` imports in a single file this way.\n\n- [`{usethis}`](https://github.com/r-lib/usethis/blob/main/R/usethis-package.R){target=\"_blank\"}\n\n- [`{lintr}`](https://github.com/r-lib/lintr/blob/main/R/lintr-package.R){target=\"_blank\"}\n\n# Conclusion\n\nYou can use these techniques to avoid repetition while developing R packages, which should make the development workflow faster, more maintainable, and less error-prone.\n\n# Advanced {.smaller}\n\nAlthough related to package development at a meta level, these issues are beyond the scope of the current presentation. I can only point to resources to help you get started.\n\n- [DRY GitHub Actions workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows){target=\"_blank\"}\n\n   - <https://github.com/krlmlr/actions-sync>\n   - <https://github.com/rstudio/education-workflows>\n\n- [DRY pkdown website templates for multiple packages in organizations](https://pkgdown.r-lib.org/articles/customise.html#template-packages){target=\"_blank\"}\n\n   - <https://github.com/tidyverse/tidytemplate>\n   - <https://github.com/easystats/easystatstemplate>\n\n# For more\n\nIf you are interested in reading more of my slide decks on related topics, visit [this](https://sites.google.com/site/indrajeetspatilmorality/presentations){target=\"_blank\"} page.\n\n# Find me at...\n\n{{< fa brands twitter >}} [Twitter](http://twitter.com/patilindrajeets){target=\"_blank\"}\n\n{{< fa brands linkedin >}} [LikedIn](https://www.linkedin.com/in/indrajeet-patil-397865174/){target=\"_blank\"}\n\n{{< fa brands github >}} [GitHub](http://github.com/IndrajeetPatil){target=\"_blank\"}\n\n{{< fa solid link >}} [Website](https://sites.google.com/site/indrajeetspatilmorality/){target=\"_blank\"}\n\n{{< fa solid envelope >}} [E-mail](mailto:patilindrajeet.science@gmail.com){target=\"_blank\"}\n\n# Thank You \n\nAnd Happy (DRY) Package Development! ðŸ˜Š\n\n## Session information {.smaller}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info(include_base = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nâ”€ Session info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n setting  value\n version  R version 4.3.3 (2024-02-29)\n os       Ubuntu 22.04.4 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  C.UTF-8\n ctype    C.UTF-8\n tz       UTC\n date     2024-03-31\n pandoc   3.1.8 @ /opt/hostedtoolcache/pandoc/3.1.8/x64/ (via rmarkdown)\n\nâ”€ Packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n package     * version date (UTC) lib source\n base        * 4.3.3   2024-03-04 [3] local\n cli           3.6.2   2023-12-11 [1] RSPM\n compiler      4.3.3   2024-03-04 [3] local\n datasets    * 4.3.3   2024-03-04 [3] local\n digest        0.6.35  2024-03-11 [1] RSPM\n evaluate      0.23    2023-11-01 [1] RSPM\n fastmap       1.1.1   2023-02-24 [1] RSPM\n graphics    * 4.3.3   2024-03-04 [3] local\n grDevices   * 4.3.3   2024-03-04 [3] local\n htmltools     0.5.8   2024-03-25 [1] RSPM\n jsonlite      1.8.8   2023-12-04 [1] RSPM\n knitr         1.45    2023-10-30 [1] RSPM\n methods     * 4.3.3   2024-03-04 [3] local\n rlang         1.1.3   2024-01-10 [1] RSPM\n rmarkdown     2.26    2024-03-05 [1] RSPM\n sessioninfo   1.2.2   2021-12-06 [1] any (@1.2.2)\n stats       * 4.3.3   2024-03-04 [3] local\n tools         4.3.3   2024-03-04 [3] local\n utils       * 4.3.3   2024-03-04 [3] local\n xfun          0.43    2024-03-25 [1] RSPM\n yaml          2.3.8   2023-12-11 [1] RSPM\n\n [1] /home/runner/work/_temp/Library\n [2] /opt/R/4.3.3/lib/R/site-library\n [3] /opt/R/4.3.3/lib/R/library\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```\n\n\n:::\n:::\n",
    "supporting": [
      "slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}